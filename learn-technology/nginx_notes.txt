## nginx-notes
## create at 2018.1.2

1、关闭nginx服务
	sudo ./nginx -s stop
	pkill -9 nginx (强行关闭)
	
二、学习网址
	1、Nginx开发从入门到精通
		http://tengine.taobao.org/book/
	2、gitbook的网址
		https://wizardforcel.gitbooks.io/nginx-doc/content/Text/1.2_nginxchswhyuseit.html
	3、一个评价比较高的博客
		http://www.cnblogs.com/jingmoxukong/p/5945200.html
	
三、笔记
1、nginx性能高的原因和其架构是分不开的。
	1.1、在unix系统中会以daemon的方式在后台运行，后台进程包含一个master进程和多个worker进程。
	1.2、nginx是以多进程的方式来工作的，当然nginx也是支持多线程的方式的，只是我们主流的方式还是多进程的方式,也是nginx的默认方式。
	1.3、多个worker进程之间是对等的,他们同等竞争来自客户端的请求,各个进程之间是独立的,也就是说：一个请求只能在一个worker进程中处理,一个worker进程
		不可能处理别的请求。
		而且，worker进程的个数是可以设置的,一般与cpu的核数一致。
	1.4、nginx在启动后，会有一个master进程和多个worker进程。
		master进程的作用：
			master进程主要用来管理worker进程，包含：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，
				当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。
			worker进程的主要作用：处理基本的基本的网络事件。
2、worker进程是如何处理请求的？
	根据“二、学习网址的第一个：”，说的是多个worker进程平等竞争，就是当有请求到来以后,多个进程来竞争这一把锁。谁抢到了，那么就由谁来执行这个请求。
	也就是获取锁。
3、nginx的这种多进程的工作方式的好处是什么？
	首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。
	其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。
4、nginx是如何实现高并发的？
	采用异步非阻塞的事件处理机制。eagain
	它们提供了一种机制，让你可以同时监控多个事件，调用他们是阻塞的，但可以设置超时时间，在超时时间之内，如果有事件准备好了，就返回。
	这种机制正好解决了我们上面的两个问题，拿epoll为例(在后面的例子中，我们多以epoll为例子，以代表这一类函数)，当事件没准备好时，放到epoll里面，
	事件准备好了，我们就去读写，当读写返回EAGAIN时，我们将它再次加入到epoll里面。这样，只要有事件准备好了，我们就去处理它，
	只有当所有事件都没准备好时，才在epoll里面等着。这样，我们就可以并发处理大量的并发了。
	这里的并发请求，是指未处理完的请求，线程只有一个，所以同时能处理的请求当然只有一个了，只是在请求间进行不断地切换而已，
	切换也是因为异步事件未准备好，而主动让出的。这里的切换是没有任何代价，你可以理解为循环处理多个准备好的事件，事实上就是这样的。
	与多线程相比，这种事件处理方式是有很大的优势的，不需要创建线程，每个请求占用的内存也很少，没有上下文切换，事件处理非常的轻量级。
	并发数再多也不会导致无谓的资源浪费（上下文切换）。更多的并发数，只是会占用更多的内存而已。
	我之前有对连接数进行过测试，在24G内存的机器上，处理的并发请求数达到过200万。现在的网络服务器基本都采用这种方式
5、一个基本的web服务器来说，事件通常有三种类型，网络事件、信号、定时器。从上面的讲解中知道，网络事件通过异步非阻塞可以很好的解决掉。如何处理信号与定时器？
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
		
	