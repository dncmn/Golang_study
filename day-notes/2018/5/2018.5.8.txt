##2018.5.8
##daily-notes



目前,游戏服务器好像没有停止运行的脚本。



查询条件: Status==constants.IapOrderChecklocalPanic &&FinalCount<5 
当开启服务器的时候,开启一条协程,这个协程不停地从数据库表中查询数据。














task
	1、错误订单,验证失败
		描述:对于一个无效的订单,然后也可以验证成功
	2、添加日志
	3、对于验证失败的订单进行重复验证-----（定时处理,验证错误订单消息）
	
	
	今天把iap验证日志那块加一下吧，还有定时检查异常状态订单重新去验证
	
一、优化有订单号进行校验。
	目前是这样的
		验证分为两部分：
			1.1、appstore的验证
			1.2、服务器本地的验证，验证这次购买的商品id在服务器是否存在
	需要优化的
		对假的订单号进行验证
			什么时候,对这个订单号进行验证,也就是对向appstore的时候
			解决方案:在向苹果验证的时候,每次发生error的时候,都会对这个状态码进行赋值。
二、添加日志。
	验证成功
	验证失败
三、定时检查异常状态订单重新去验证

	var res []model.IapOrderLogSaveFail{}
	err=gloDb.Model(&model.IapOrderLogSaveFail{}).Where("status=? and uid=? and transcaionId=?",constants.IapOrderCheckLocalPanic).Find(&res).Error


	思路:
		当出现验证失败(本地服务器异常)，然后取出本次验证的数据,
		
		step-one:找出当次的异常的记录(但是当时找到了这些异常记录,但是又出产生新的记录)
		step-two:再次向苹果发送验证信息
			前提:orderStatus.FailCount<=5
			
思路一：
	如果需要验证了，可以每次都进行五次，如果验证成功了，直接跳出循环,然后返回。
	如果第一次验证失败了，然后进行第二次循环，进行第二次验证。不行的话，那就第三次，直到进行五次验证。
	如果五次验证都失败了，那就把本次验证设置成验证失败。然后就可以给客户端返回了
思路二：
	疑问：
		1.1、如果将所有的异常都保存到数据库中,然后定时对这个表中的数据做校验，
			但是检验过后呢,如果客户端过来验证消息(等待服务器的验证)，服务器验证失败了
		1.2、什么时候开启这个协程，什么时候关闭这个协程
			(按照之前的经验,通过结合channel，在开启开启游戏服务器的时候,开启一个协程，在关闭游戏服务器的时候,给这个协程传递一个信号量,然后来关闭这个协程。)
			

	步骤：(查询条件: Status==constants.IapOrderChecklocalPanic &&FinalCount<5 )
		1、从数据库表中判断是否有数据存在,没有的话,程序就休眠2分钟,然后再获取一次。
		2、查询数据时,只找本地异常的,比如数据库崩掉,订单物品本次不存在。
		3、判断当前记录如果尝试到了五次就跳过这一条记录,没有的话,就继续,直到五次为止。
		4、
			验证成功:程序该如何处理
			验证失败：更改数据库中的本条记录的FailCount
		
		
	
		
		
		
		



开启一个协程
go func(){

for{


}



}()
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		